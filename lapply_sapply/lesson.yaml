- Class: meta
  Course: beginR
  Lesson: lapply_sapply
  Author: Joris SANSEN
  Type: Standard
  Organization: bordeaux INP / ENSTBB
  Version: 2.4.5

- Class: text
  Output: "Dans ce cours, vous allez apprendre à utiliser lapply() et sapply(), les deux membres les plus importants de la famille de fonction *apply de R, aussi connu comme fonctions de boucles."

- Class: text
  Output: "Ces fonctions sont très puissantes, tout comme leurs homologues telles que vapply() et tapply(), et offrent une moyens pratique et concis d'implementer des stratégies du type séparer-appliquer-rassembler couramment utilisé en analyses de données."

- Class: text
  Output: "Toutes les fonctions de la famille *apply opèrent de la façon suivante: 1. séparer (split) les données en éléments plus petits (selon des modalités qui leurs sont propres), 2. appliquer une fonction sur chacun de ces éléments, 3. combiner le résultat. Pour une description plus détaillée de cette strategie, vous pouvez vous réferrer à l'article de Hadley Wickham dans le Journal of Statistical Software paper intitulé 'The Split-Apply-Combine Strategy for Data Analysis'. Vous le trouverez en accès libre ici: https://www.jstatsoft.org/article/view/v040i01 "

- Class: text
  Output: "Tout le long de ce cours, nous allons utiliser le jeu de données 'Flags' fournit sur le dépot UCI Machine Learning. Ce jeu de données représente des informations concernant les pays et leurs drapeaux respectifs et peut être obtenu ici: http://archive.ics.uci.edu/ml/datasets/Flags"

- Class: text
  Output: "Attaquons tout de suite les choses sérieuses pour que vous ayez directement un aperçu de l'intérêt de ces fonctions et de leurs fonctionnement."

- Class: cmd_question
  Output: "J'ai d'ores et déjà stocké ces fonctions dans une variable appelée flags. Tapez head(flags) pour afficher les 6 premières lignes des données."
  CorrectAnswer: head(flags)
  AnswerTests: omnitest(correctExpr='head(flags)')
  Hint: "Tapez head(flags) pour afficher la 'tête' des données, c'est-à-dire les quelques premières lignes".

- Class: cmd_question
  Output: "Vous pourrez avoir besoin de 'scroller' (dérouler) l'affichage pour voir toutes les sorties de vos commandes. Maintenant vérifiez les dimensions du jeu de données en tuilisant la fonction dim()"
  CorrectAnswer: dim(flags)
  AnswerTests: omnitest(correctExpr='dim(flags)')
  Hint: "Tapez dim(flags) pour voir les dimensions du jeu de données."

- Class: text
  Output: "On voit donc que le jeu de données est composé de 194 lignes, aussi appelées observations, et 30 colonnes, appelées variables. A chaque observations correspond un pays et chaque variable représente une caractéristique du pays ou de son drapeau. Pour afficher une description plus complète du jeu de données dans un fichier de texte séparé, tapez viewinfo() dans la console."

- Class: cmd_question
  Output: "Comme avec tout jeu de données, il est important de savori sous quel format les données ont été stockées. En d'autres termes, quelle est la classe de chaque variable? Pour cela, on va tout d'abord utiliser la commande class(flags). A vous."
  CorrectAnswer: class(flags)
  AnswerTests: omnitest(correctExpr='class(flags)')
  Hint: "Tapez class(flags) pour voir ce que cela produit."

- Class: text
  Output: "Cela nous indique juste que tout le jeu de données est stocké sous forme de 'data.frame', ce qui ne répond pas réellement à notre question. En fait, il faut appeler la fonction class() sur chaque variable des données. Tandis que nous pourrions le faire manuellement (appeler la commande class sur chaque colonne, l'une après l'autre), il est bien plus rapide d'automatiser ce processus. Il nous faut donc obtenir les colonnes, l'une après l'autre pour leur appliquer à chacune la fonction class()... cela ressemble fortement à une boucle!"

- Class: text
  Output: "la fonction lapply prend une liste en entrée, applique une fonction à chaque élément de la liste et retourne une liste de la même taille que la liste originale. Puisqu'un dataframe n'est rien d'autre qu'une liste de vecteurs (vous pouvez le voir en tapant as.list(flags)), nous pouvons simplement utiliser lapply() pour appliquer la fonction class() sur chaque colonne des données flags. Voyons cela !"

- Class: cmd_question
  Output: "Tapez cls_list = lapply(flags, class) pour appliquer la fonction class (le deuxième argument de l'appel), sur chaque élément de la varaible flags (nos données fournies en premier argument), et stocker le résultat dans une variable appelée cls_list. Remarquez comme on a tout simplement indiqué le nom de la fonction à appliquer (ici, class) sans les parenthèses qui suivent traditionnellement l'appel à une fonction. c'est le même mécanisme que celui présenté pour le passage de fonction en argument de fonction."
  CorrectAnswer: cls_list <- lapply(flags, class)
  AnswerTests: omnitest(correctExpr='cls_list = lapply(flags, class)')
  Hint: "Tapez cls_list = lapply(flags, class) pour appliquer la fonction class() à chaque colonne de nos données et  stocker le résultat dans une variable appelée cls_list."

- Class: cmd_question
  Output: Tapez cls_list pour voir le résultat.
  CorrectAnswer: cls_list
  AnswerTests: omnitest(correctExpr='cls_list')
  Hint: Tapez simplement 'cls_list' pour voir le résultat.

- Class: cmd_question
  Output: "Le 'l' de 'lapply' vient donc des listes que la fonction retourne. Tapez class(cls_list) pour vérifier que la fonction lapply() retourne bel et bien une liste."
  CorrectAnswer: class(cls_list)
  AnswerTests: omnitest(correctExpr='class(cls_list)')
  Hint: "Tapez class(cls_list) pour confirmer que la fonction retourne bien une liste."

- Class: text
  Output: "Comme attendu, on obtient une liste de taille 30 -- un élément pour chaque variable (nos colonnes). Cependant, la sortie de notre fonction serait largement plus compacte si nous pouvions représenter la réponse sous la forme d'un vecteur au lieu d'une liste."

- Class: cmd_question
  Output: "Vous vous rappelez peut-être que dans un précédent cours, nous avions expliqué que les listes étaient pratiques pour stocker des données de types/classes différent-e-s. Dans notre cas, puisque chaque élément de la liste retournée par la fonction lapply est un vecteur de taille 1 contenant une chaîne de caractères, la variable cls_list peut être simplifiée en un simple vecteur de chaine de caractères. Pour faire cela, on peut effectuer une simple conversion avec la commande as.character(cls_list)."
  CorrectAnswer: as.character(cls_list)
  AnswerTests: omnitest(correctExpr='as.character(cls_list)')
  Hint: Tapez as.character(cls_list) pour convertir  cls_list en un vecteur de chaines de caractères.

- Class: cmd_question
  Output: "La fonction sapply permet d'automatiser cette procédure (elle appelle lapply en interne) puis en essayant de simplifier le résultat avant de nous le retourner. D'où le 's' de 'sapply' (pour 'simplify'). Utilisez sapply() de la même façon que lapply pour obtenir la classe de chaque colonne des données flags et stockez le résultat dans une variable appelée cls_vect. Si vous avez besoin d'aide, n"hésitez pas à utiliser ?sapply pour en afficher la documentation."
  CorrectAnswer: cls_vect <- sapply(flags, class)
  AnswerTests: omnitest(correctExpr='cls_vect <- sapply(flags, class)')
  Hint: "Bloqué-e? Tapez cls_vect = sapply(flags, class) pour stocker les classes de colonnes dans un vecteur de chaine de caractères appelé cls_vect."

- Class: cmd_question
  Output: "Utilisez class(cls_vect) pour confirmer que sapply() simplifie le résultat sous la forme d'un vecteur de chaine de caractères."
  CorrectAnswer: class(cls_vect)
  AnswerTests: omnitest(correctExpr='class(cls_vect)')
  Hint: "Tapez class(cls_vect) pour confirmer que sapply() simplifie le résultat sous la forme d'un vecteur de chaine de caractères."

- Class: text
  Output: In general, if the result is a list where every element is of length one, then sapply() returns a vector. If the result is a list where every element is a vector of the same length (> 1), sapply() returns a matrix. If sapply() can't figure things out, then it just returns a list, no different from what lapply() would give you.

- Class: text
  Output: Let's practice using lapply() and sapply() some more!

- Class: text
  Output: Columns 11 through 17 of our dataset are indicator variables, each representing a different color. The value of the indicator variable is 1 if the color is present in a country's flag and 0 otherwise.

- Class: cmd_question
  Output:  Therefore, if we want to know the total number of countries (in our dataset) with, for example, the color orange on their flag, we can just add up all of the 1s and 0s in the 'orange' column. Try sum(flags$orange) to see this.
  CorrectAnswer: sum(flags$orange)
  AnswerTests: omnitest(correctExpr='sum(flags$orange)')
  Hint: Use sum(flags$orange) to add up all of the 1s and 0s in the 'orange' column.

- Class: text
  Output: Now we want to repeat this operation for each of the colors recorded in the dataset.

- Class: cmd_question
  Output: First, use flag_colors <- flags[, 11:17] to extract the columns containing the color data and store them in a new data frame called flag_colors. (Note the comma before 11:17. This subsetting command tells R that we want all rows, but only columns 11 through 17.)
  CorrectAnswer: flag_colors <- flags[, 11:17]
  AnswerTests: omnitest(correctExpr='flag_colors <- flags[, 11:17]')
  Hint: flag_colors <- flags[, 11:17] will get the job done!

- Class: cmd_question
  Output: Use the head() function to look at the first 6 lines of flag_colors.
  CorrectAnswer: head(flag_colors)
  AnswerTests: omnitest(correctExpr='head(flag_colors)')
  Hint: head(flag_colors) will display the first six lines of flag_colors.

- Class: cmd_question
  Output: To get a list containing the sum of each column of flag_colors, call the lapply() function with two arguments. The first argument is the object over which we are looping (i.e. flag_colors) and the second argument is the name of the function we wish to apply to each column (i.e. sum). Remember that the second argument is just the name of the function with no parentheses, etc.
  CorrectAnswer: lapply(flag_colors, sum)
  AnswerTests: omnitest(correctExpr='lapply(flag_colors, sum)')
  Hint: Use lapply(flag_colors, sum) to return the sum of each column.

- Class: text
  Output: This tells us that of the 194 flags in our dataset, 153 contain the color red, 91 contain green, 99 contain blue, and so on.

- Class: cmd_question
  Output: The result is a list, since lapply() always returns a list. Each element of this list is of length one, so the result can be simplified to a vector by calling sapply() instead of lapply(). Try it now.
  CorrectAnswer: sapply(flag_colors, sum)
  AnswerTests: omnitest(correctExpr='sapply(flag_colors, sum)')
  Hint: Use sapply(flag_colors, sum) to return a vector of column sums.

- Class: text
  Output: Perhaps it's more informative to find the proportion of flags (out of 194) containing each color. Since each column is just a bunch of 1s and 0s, the arithmetic mean of each column will give us the proportion of 1s. (If it's not clear why, think of a simpler situation where you have three 1s and two 0s -- (1 + 1 + 1 + 0 + 0)/5 = 3/5 = 0.6).

- Class: cmd_question
  Output: Use sapply() to apply the mean() function to each column of flag_colors. Remember that the second argument to sapply() should just specify the name of the function (i.e. mean) that you want to apply.
  CorrectAnswer: sapply(flag_colors, mean)
  AnswerTests: omnitest(correctExpr='sapply(flag_colors, mean)')
  Hint: sapply(flag_colors, mean) will do the trick!

- Class: text
  Output: In the examples we've looked at so far, sapply() has been able to simplify the result to vector. That's because each element of the list returned by lapply() was a vector of length one. Recall that sapply() instead returns a matrix when each element of the list returned by lapply() is a vector of the same length (> 1).

- Class: cmd_question
  Output: To illustrate this, let's extract columns 19 through 23 from the flags dataset and store the result in a new data frame called flag_shapes. flag_shapes <- flags[, 19:23] will do it.
  CorrectAnswer: flag_shapes <- flags[, 19:23]
  AnswerTests: omnitest(correctExpr='flag_shapes <- flags[, 19:23]')
  Hint: flag_shapes <- flags[, 19:23] will save columns 19 through 23 in a new variable.

- Class: text
  Output: Each of these columns (i.e. variables) represents the number of times a particular shape or design appears on a country's flag. We are interested in the minimum and maximum number of times each shape or design appears.

- Class: cmd_question
  Output: The range() function returns the minimum and maximum of its first argument, which should be a numeric vector. Use lapply() to apply the range function to each column of flag_shapes. Don't worry about storing the result in a new variable. By now, we know that lapply() always returns a list.
  CorrectAnswer: lapply(flag_shapes, range)
  AnswerTests: omnitest(correctExpr='lapply(flag_shapes, range)')
  Hint: Try lapply(flag_shapes, range) to apply the range() function to each column of flag_shapes.

- Class: cmd_question
  Output: Do the same operation, but using sapply() and store the result in a variable called shape_mat.
  CorrectAnswer: shape_mat <- sapply(flag_shapes, range)
  AnswerTests: omnitest(correctExpr='shape_mat <- sapply(flag_shapes, range)')
  Hint: shape_mat <- sapply(flag_shapes, range) will apply the range() function to each column of flag_shapes and store the result in shape_mat.

- Class: cmd_question
  Output: View the contents of shape_mat.
  CorrectAnswer: shape_mat
  AnswerTests: any_of_exprs('shape_mat', 'print(shape_mat)')
  Hint: Type shape_mat to view its contents.

- Class: text
  Output: Each column of shape_mat gives the minimum (row 1) and maximum (row 2) number of times its respective shape appears in different flags.

- Class: cmd_question
  Output: Use the class() function to confirm that shape_mat is a matrix.
  CorrectAnswer: class(shape_mat)
  AnswerTests: omnitest(correctExpr='class(shape_mat)')
  Hint: class(shape_mat) returns the class of shape_mat.

- Class: text
  Output: As we've seen, sapply() always attempts to simplify the result given by lapply(). It has been successful in doing so for each of the examples we've looked at so far. Let's look at an example where sapply() can't figure out how to simplify the result and thus returns a list, no different from lapply().

- Class: cmd_question
  Output: When given a vector, the unique() function returns a vector with all duplicate elements removed. In other words, unique() returns a vector of only the 'unique' elements. To see how it works, try unique(c(3, 4, 5, 5, 5, 6, 6)).
  CorrectAnswer: unique(c(3, 4, 5, 5, 5, 6, 6))
  AnswerTests: omnitest(correctExpr='unique(c(3, 4, 5, 5, 5, 6, 6))')
  Hint: Do unique(c(3, 4, 5, 5, 5, 6, 6)) to see how the unique() function works.

- Class: cmd_question
  Output: We want to know the unique values for each variable in the flags dataset. To accomplish this, use lapply() to apply the unique() function to each column in the flags dataset, storing the result in a variable called unique_vals.
  CorrectAnswer: unique_vals <- lapply(flags, unique)
  AnswerTests: omnitest(correctExpr='unique_vals <- lapply(flags, unique)')
  Hint: Try unique_vals <- lapply(flags, unique).

- Class: cmd_question
  Output: Print the value of unique_vals to the console.
  CorrectAnswer: unique_vals
  AnswerTests: any_of_exprs('unique_vals', 'print(unique_vals)')
  Hint: Type unique_vals to view its contents.

- Class: cmd_question
  Output: "Since unique_vals is a list, you can use what you've learned to determine the length of each element of unique_vals (i.e. the number of unique values for each variable). Simplify the result, if possible. Hint: Apply the length() function to each element of unique_vals."
  CorrectAnswer: sapply(unique_vals, length)
  AnswerTests: omnitest(correctExpr='sapply(unique_vals, length)')
  Hint: Apply the length() function to each element of the unique_vals list using sapply(). Remember, no parentheses after the name of the function you are applying (i.e. length).

- Class: text
  Output: The fact that the elements of the unique_vals list are all vectors of *different* length poses a problem for sapply(), since there's no obvious way of simplifying the result.

- Class: cmd_question
  Output: Use sapply() to apply the unique() function to each column of the flags dataset to see that you get the same unsimplified list that you got from lapply().
  CorrectAnswer: sapply(flags, unique)
  AnswerTests: omnitest(correctExpr='sapply(flags, unique)')
  Hint: Use sapply(flags, unique) to apply the unique function to each column of flags, failing to simplify the result.

- Class: text
  Output: Occasionally, you may need to apply a function that is not yet defined, thus requiring you to write your own. Writing functions in R is beyond the scope of this lesson, but let's look at a quick example of how you might do so in the context of loop functions.

- Class: text
  Output: Pretend you are interested in only the second item from each element of the unique_vals list that you just created. Since each element of the unique_vals list is a vector and we're not aware of any built-in function in R that returns the second element of a vector, we will construct our own function.

- Class: cmd_question
  Output: lapply(unique_vals, function(elem) elem[2]) will return a list containing the second item from each element of the unique_vals list. Note that our function takes one argument, elem, which is just a 'dummy variable' that takes on the value of each element of unique_vals, in turn.
  CorrectAnswer: lapply(unique_vals, function(elem) elem[2])
  AnswerTests: calculates_same_value('lapply(unique_vals, function(elem) elem[2])')
  Hint: Use lapply(unique_vals, function(elem) elem[2]) to return a list containing the second item from each element of the unique_vals list.

- Class: text
  Output: The only difference between previous examples and this one is that we are defining and using our own function right in the call to lapply(). Our function has no name and disappears as soon as lapply() is done using it. So-called 'anonymous functions' can be very useful when one of R's built-in functions isn't an option.

- Class: text
  Output: In this lesson, you learned how to use the powerful lapply() and sapply() functions to apply an operation over the elements of a list. In the next lesson, we'll take a look at some close relatives of lapply() and sapply().

- Class: mult_question
  Output: Would you like to inform someone about your successful completion of
    this lesson via email?
  CorrectAnswer: NULL
  AnswerChoices: Yes; No
  AnswerTests: notify()
  Hint: NULL
